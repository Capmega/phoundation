<?php

/**
 * Class Response
 *
 * This class manages the execution and processing of response to Commands, HTML, AJAX and API requests.
 *
 * @author    Sven Olaf Oostenbrink <so.oostenbrink@gmail.com>
 * @license   http://opensource.org/licenses/GPL-2.0 GNU Public License, Version 2
 * @copyright Copyright (c) 2024 Sven Olaf Oostenbrink <so.oostenbrink@gmail.com>
 * @package   Phoundation\Web
 */


declare(strict_types=1);

namespace Phoundation\Web\Requests;

use JetBrains\PhpStorm\NoReturn;
use Phoundation\Cache\Cache;
use Phoundation\Cache\InstanceCache;
use Phoundation\Core\Core;
use Phoundation\Core\Locale\Language\Interfaces\LanguageInterface;
use Phoundation\Core\Locale\Language\Language;
use Phoundation\Core\Log\Log;
use Phoundation\Core\Sessions\Session;
use Phoundation\Data\Interfaces\IteratorInterface;
use Phoundation\Data\Iterator;
use Phoundation\Data\Traits\TraitDataStaticFlashMessages;
use Phoundation\Data\Traits\TraitDataStaticContentType;
use Phoundation\Data\Traits\TraitDataStaticExecuted;
use Phoundation\Data\Traits\TraitGetInstance;
use Phoundation\Date\Date;
use Phoundation\Date\Time;
use Phoundation\Exception\OutOfBoundsException;
use Phoundation\Filesystem\Exception\FilesystemException;
use Phoundation\Filesystem\FsFile;
use Phoundation\Filesystem\FsPath;
use Phoundation\Filesystem\FsRestrictions;
use Phoundation\Filesystem\Traits\TraitDataStaticRestrictions;
use Phoundation\Notifications\Notification;
use Phoundation\Os\Processes\Process;
use Phoundation\Utils\Arrays;
use Phoundation\Utils\Config;
use Phoundation\Utils\Numbers;
use Phoundation\Utils\Strings;
use Phoundation\Web\Html\Components\Input\Interfaces\RenderInterface;
use Phoundation\Web\Html\Components\Interfaces\ScriptInterface;
use Phoundation\Web\Html\Components\Script;
use Phoundation\Web\Html\Components\Widgets\BreadCrumbs;
use Phoundation\Web\Html\Components\Widgets\FlashMessages\FlashMessages;
use Phoundation\Web\Html\Components\Widgets\FlashMessages\Interfaces\FlashMessagesInterface;
use Phoundation\Web\Html\Components\Widgets\Interfaces\BreadCrumbsInterface;
use Phoundation\Web\Html\Enums\EnumAttachJavascript;
use Phoundation\Web\Html\Enums\EnumJavascriptWrappers;
use Phoundation\Web\Http\Exception\HttpException;
use Phoundation\Web\Http\Interfaces\UrlInterface;
use Phoundation\Web\Http\Url;
use Phoundation\Web\Requests\Enums\EnumRequestTypes;
use Phoundation\Web\Requests\Exception\PageNotFoundException;
use Phoundation\Web\Requests\Exception\ResponseHeadersException;
use Phoundation\Web\Requests\Exception\ResponseRedirectException;
use Phoundation\Web\Requests\Interfaces\ResponseInterface;
use Phoundation\Web\Uploads\Interfaces\UploadHandlersInterface;
use Phoundation\Web\Uploads\UploadHandlers;
use PHPMD\Renderer\Option\Color;
use Stringable;
use Throwable;


class Response implements ResponseInterface
{
    use TraitDataStaticFlashMessages;
    use TraitDataStaticContentType;
    use TraitDataStaticExecuted;
    use TraitDataStaticRestrictions;
    use TraitGetInstance;

    /**
     * Singleton instance
     *
     * @var ResponseInterface $instance
     */
    protected static ResponseInterface $instance;

    /**
     * The output generated by the request
     *
     * @var string|null $output
     */
    protected static ?string $output = null;

    /**
     * The status code that will be returned to the client
     *
     * @var int $http_code
     */
    protected static int $http_code = 200;

    /**
     * Tracks if static::sendHeaders() sent headers already or not.
     *
     * @note IMPORTANT: Since flush() and ob_flush() will NOT lock headers until the buffers are actually flushed, and
     *                  they will neither actually flush the buffers as long as the process is running AND the buffers
     *                  are not full yet, weird things can happen. With a buffer of 4096 bytes (typically), echo 100
     *                  characters, and then execute static::sendHeaders(), then ob_flush() and flush() and
     *                  headers_sent() will STILL be false, and REMAIN false until the buffer has reached 4096
     *                  characters OR the process ends. This variable just keeps track if static::sendHeaders() has been
     *                  executed (and it won't execute again), but headers might still be sent out manually. This is
     *                  rather messed up, because it really shows as if information was sent, the buffers are flushed,
     *                  yet nothing is actually flushed, so the headers are also not sent. This is just messed up PHP.
     *
     * @var bool $http_headers_sent
     */
    protected static bool $http_headers_sent = false;

    /**
     * Keeps track on if the HTML headers have been sent / generated or not
     *
     * @var bool $html_headers_sent
     */
    protected static bool $html_headers_sent = false;

    /**
     * Information that goes into the HTML header
     *
     * @var array $http_headers
     */
    protected static array $http_headers;

    /**
     * CORS headers
     *
     * @var array $cors
     */
    protected static array $cors = [];

    /**
     * Classes to apply on default sections of the page
     *
     * @var array $page_classes
     */
    protected static array $page_classes = [];

    /**
     * The client specified ETAG for this request
     *
     * @var string|null $etag
     */
    protected static ?string $etag = null;

    /**
     * !DOCTYPE variable
     *
     * @var string
     */
    protected static string $doctype = 'html';

    /**
     * The browser page title
     *
     * @var string|null $page_title
     */
    protected static ?string $page_title = null;

    /**
     * The browser page description
     *
     * @var string|null $description
     */
    protected static ?string $description = null;

    /**
     * The page header title
     *
     * @var string|null $header_title
     */
    protected static ?string $header_title = null;

    /**
     * The page header subtitle
     *
     * @var string|null $header_sub_title
     */
    protected static ?string $header_sub_title = null;

    /**
     * Bread crumbs for this page
     *
     * @var BreadCrumbs
     */
    protected static BreadCrumbs $bread_crumbs;

    /**
     * If true, the template will build the <body> tag. If false, the page will have to build it itself
     *
     * @var bool $render_main_wrapper
     */
    protected static bool $render_main_wrapper = true;

    /**
     * @var string $language_code
     */
    protected static string $language_code;

    /**
     * @var LanguageInterface $language
     */
    protected static LanguageInterface $language;

    /**
     * Tracks data that goes into the HTML footers
     *
     * @var array $page_footers
     */
    protected static array $page_footers;

    /**
     * Tracks data that goes into the HTML headers
     *
     * @var array $page_headers
     */
    protected static array $page_headers;

    /**
     * Tracks the total number of bytes sent
     *
     * @var int $bytes_sent
     */
    protected static int $bytes_sent = 0;

    /**
     * Sets if the request should render the entire page or the contents of the page only
     *
     * @var bool $render_main_contents_only
     */
    protected static bool $render_main_contents_only = false;


    /**
     * Response class constructor
     */
    protected function __construct()
    {
        // Take restrictions from Request object
        static::$restrictions = Request::getRestrictions();
        static::$http_headers = [];
        static::$page_headers = [
            'link'       => [],
            'javascript' => [],
            'meta'       => [
                'charset'  => Config::get('languages.encoding.charset', 'UTF-8'),
                'viewport' => Config::get('web.viewport', 'width=device-width, initial-scale=1, shrink-to-fit=no'),
            ],
        ];
        static::$page_footers = [
            'javascript' => [],
        ];
    }


    /**
     * Initializes the Response object
     *
     * @return void
     */
    public static function initialize(): void
    {
        static::getInstance();
    }


    /**
     * Returns the total number of bytes sent to the client
     *
     * @return int
     */
    public static function getBytesSent(): int
    {
        return static::$bytes_sent;
    }


    /**
     * Returns the alternative class for the <body> tag or if not preset, the default
     *
     * @return bool
     */
    public static function getRenderMainWrapper(): bool
    {
        return static::$render_main_wrapper;
    }


    /**
     * Sets an alternative class for the <body> tag
     *
     * @param bool $render_main_wrapper
     *
     * @return void
     */
    public static function setRenderMainWrapper(bool $render_main_wrapper): void
    {
        static::$render_main_wrapper = $render_main_wrapper;
    }


    /**
     * Sets the class for the given page section
     *
     * @param string $class
     * @param string $section
     *
     * @return void
     */
    public static function setClass(string $class, string $section): void
    {
        static::$page_classes[$section] = $class;
    }


    /**
     * Sets the class for the given page section
     *
     * @param string $class
     * @param string $section
     *
     * @return void
     */
    public static function defaultClass(string $class, string $section): void
    {
        if (empty(static::$page_classes[$section])) {
            static::$page_classes[$section] = $class;
        }
    }


    /**
     * Returns the class for the given section, if available
     *
     * @param string      $section
     * @param string|null $default
     *
     * @return string|null
     */
    public static function getClass(string $section, ?string $default = null): ?string
    {
        return isset_get(static::$page_classes[$section], $default);
    }


    /**
     * Returns the bread crumbs for this page
     *
     * @return BreadCrumbsInterface
     */
    public static function getBreadCrumbs(): BreadCrumbsInterface
    {
        if (empty(static::$bread_crumbs)) {
            static::$bread_crumbs = new BreadCrumbs();
        }

        return static::$bread_crumbs;
    }


    /**
     * Sets the bread crumbs for this page
     *
     * @param BreadCrumbsInterface|null $bread_crumbs
     *
     * @return void
     */
    public static function setBreadCrumbs(?BreadCrumbsInterface $bread_crumbs = null): void
    {
        if (!$bread_crumbs) {
            static::$bread_crumbs = new BreadCrumbs();
        } else {
            static::$bread_crumbs = $bread_crumbs;
        }
    }


    /**
     * Returns the DOCTYPE value
     *
     * @return string
     */
    public static function getDocType(): string
    {
        return static::$doctype;
    }


    /**
     * Sets  the DOCTYPE value
     *
     * @param string $doctype
     *
     * @return void
     */
    public static function setDoctype(string $doctype): void
    {
        static::$doctype = $doctype;
    }


    /**
     * Returns the browser page title
     *
     * @return string|null
     */
    public static function getDescription(): ?string
    {
        return static::$description;
    }


    /**
     * Sets the browser page description
     *
     * @param string|null $description
     *
     * @return void
     */
    public static function setDescription(?string $description): void
    {
        static::$description = strip_tags($description);
    }


    /**
     * Returns the page header title
     *
     * @return string|null
     */
    public static function getHeaderTitle(): ?string
    {
        return static::$header_title;
    }


    /**
     * Sets the page header title
     *
     * @param Stringable|string|float|int|null $header_title
     * @param bool                             $force
     *
     * @return void
     */
    public static function setHeaderTitle(Stringable|string|float|int|null $header_title, bool $force = true): void
    {
        if (empty(static::$header_title) or $force) {
            static::$header_title = get_null((string) $header_title);

            if (!static::$page_title) {
                static::$page_title = Config::get('project.name', 'Phoundation') . ' - ' . $header_title;
            }
        }
    }


    /**
     * Returns the page header subtitle
     *
     * @return string|null
     */
    public static function getHeaderSubTitle(): ?string
    {
        return static::$header_sub_title;
    }


    /**
     * Sets the page header subtitle
     *
     * @param Stringable|string|float|int|null $header_sub_title
     * @param bool                             $force
     *
     * @return void
     */
    public static function setHeaderSubTitle(Stringable|string|float|int|null $header_sub_title, bool $force = true): void
    {
        if (empty(static::$header_title) or $force) {
            static::$header_sub_title = get_null((string) $header_sub_title);
        }
    }


    /**
     * Returns the page charset
     *
     * @return string|null
     */
    public static function getCharset(): ?string
    {
        return isset_get(static::$page_headers['meta']['charset']);
    }


    /**
     * Sets the page charset
     *
     * @param string|null $charset
     *
     * @return void
     */
    public static function setCharset(?string $charset): void
    {
        static::$page_headers['meta']['charset'] = $charset;
    }


    /**
     * Returns the page viewport
     *
     * @return string|null
     */
    public static function getViewport(): ?string
    {
        return isset_get(static::$page_headers['meta']['viewport']);
    }


    /**
     * Sets the page viewport
     *
     * @param string|null $viewport
     *
     * @return void
     */
    public static function setViewport(?string $viewport): void
    {
        static::$page_headers['meta']['viewport'] = $viewport;
    }


    /**
     * Add meta-information
     *
     * @param string                $key
     * @param string|int|float|null $value
     *
     * @return void
     */
    public static function addMeta(string $key, string|int|float|null $value): void
    {
        static::$page_headers['meta'][$key] = $value;
    }


    /**
     * Returns the current page footers for this request
     *
     * @return array
     */
    public static function getPageFooters(): array
    {
        return static::$page_footers;
    }


    /**
     * Set the favicon for this page
     *
     * @param string|null $url
     *
     * @return void
     */
    public static function setFavIcon(?string $url = null): void
    {
        try {
            if (!$url) {
                $url  = 'img/favicons/' . Core::getProjectSeoName() . '/project.png';
                $url  = static::versionFile($url, 'img');
                $file = FsPath::absolutePath(LANGUAGE . '/' . $url, DIRECTORY_CDN);

                static::$page_headers['link'][$url] = [
                    'rel'  => 'icon',
                    'href' => Url::getImg($url),
                    'type' => FsFile::new($file, FsRestrictions::getCdn())->getMimetype(),
                ];

            } else {
                $url = static::versionFile($url, 'img');

                // Unknown (likely remote?) link
                static::$page_headers['link'][$url] = [
                    'rel'  => 'icon',
                    'href' => Url::getImg($url),
                    'type' => 'image/' . Strings::fromReverse($url, '.'),
                ];
            }

        } catch (FilesystemException $e) {
            Log::warning(tr('Failed to find favicon, see next message for more information'), 3);
            Log::warning($e->makeWarning(), 3);
        }
    }


    /**
     * Will automatically add the timestamp of the specified file as a versioning string
     *
     * This is done for efficient caching where you can pretty much set cache to 10 years as changes are picked up by
     * updated versions of the files
     *
     * @see http://particletree.com/notebook/automatically-version-your-css-and-javascript-files/
     *
     * @param string $url
     * @param string $type
     *
     * @return string
     */
    public static function versionFile(string $url, string $type): string
    {
        static $minified;
        // Ensure the extension is stripped
        $url = Strings::until($url, '.' . $url);
        // Should we load the minified version? This is optional as long as the file itself does not have .min specified
        if (str_ends_with($url, '.min')) {
            if (!isset($minified)) {
                // All files are minified or none are
                $minified = (Config::get('web.minified', true) ? '.min' : '');
            }
        }
        if (Config::getBoolean('cache.version-files', true)) {
            // Determine the absolute file path
            // then get timestamp and inject it into the given file
            $file = DIRECTORY_DATA . 'content/cdn/' . LANGUAGE . '/' . $type . '/' . $url . $minified . $type;
            $url  = Strings::untilReverse($url, '.') . '.' . filectime($file) . '.' . Strings::fromReverse($url, '.');
        }

        return $url;
    }


    /**
     * Returns true if the specified HTTP code is the specified HTTP code
     *
     * @param int $code
     *
     * @return bool
     */
    public static function isHttpCode(int $code): bool
    {
        return static::$http_code === $code;
    }


    /**
     * Returns true if the HTTP headers have been sent
     *
     * @return bool
     */
    public static function getHttpHeadersSent(): bool
    {
        return static::$http_headers_sent;
    }


    /**
     * Returns the HTTP headers for this response
     *
     * @return IteratorInterface
     */
    public static function getHttpHeaders(): IteratorInterface
    {
        return static::$http_headers;
    }


    /**
     * Sets the HTTP headers for this response
     *
     * @return void
     */
    public static function setHttpHeaders(IteratorInterface|array $http_headers): void
    {
        if (is_array($http_headers)) {
            $http_headers = new Iterator($http_headers);
        }
        static::$http_headers = $http_headers;
    }


    /**
     * Add the specified HTML to the HEAD tag
     *
     * @param string $key
     * @param array  $entry
     *
     * @return void
     * @todo This should -in the near future- be updated to sending Javascript, Css, etc objects instead of "some array"
     */
    public static function addToHeader(string $key, array $entry): void
    {
        static::$http_headers[$key][] = $entry;
    }


    /**
     * Sets the status code that will be sent to the client
     *
     * @param string $origin
     * @param string $methods
     * @param string $headers
     *
     * @return void
     */
    public static function setCors(string $origin, string $methods, string $headers): void
    {
        // Validate CORS data
        // TODO implement validation
        static::$cors = [
            'origin'  => '*.',
            'methods' => 'GET, POST',
            'headers' => '',
        ];
    }


    /**
     * Returns if the HTML headers have been sent
     *
     * @return bool
     */
    public static function getHtmlHeadersSent(): bool
    {
        return static::$html_headers_sent;
    }


    /**
     * Load the specified javascript file(s)
     *
     * @param string|array $urls
     * @param bool|null    $header
     * @param bool         $prefix If true, the scripts will be added at the beginning of the scripts list
     *
     * @return void
     */
    public static function loadJavascript(string|array $urls, ?bool $header = null, bool $prefix = false): void
    {
        if ($header === null) {
            $header = !Config::getBoolean('web.javascript.delay', true);
        }

        if ($header and static::$html_headers_sent) {
            Log::warning(tr('Not adding files ":files" to HTML headers as the HTML headers have already been generated', [
                ':files' => $urls,
            ]));
        }

        $scripts = [];

        // Convert the given URL (parts) to real URLs and add it to the scripts list
        foreach (Arrays::force($urls, ',') as $url) {
            $url           = Strings::ensureEndsNotWith($url, '.js');
            $url           = Strings::ensureEndsNotWith($url, '.min');
            $url           = static::versionFile($url, 'js');
            $scripts[$url] = [
                'type' => 'text/javascript',
                'src'  => Url::getJs($url),
            ];
        }

        // Add scripts to header or footer
        if ($header) {
            if ($prefix) {
                static::$page_headers['javascript'] = array_merge($scripts, static::$page_headers['javascript']);

            } else {
                static::$page_headers['javascript'] = array_merge(static::$page_headers['javascript'], $scripts);
            }

        } else {
            if ($prefix) {
                static::$page_footers['javascript'] = array_merge($scripts, static::$page_footers['javascript']);

            } else {
                static::$page_footers['javascript'] = array_merge(static::$page_footers['javascript'], $scripts);
            }
        }
    }


    /**
     * Load the specified CSS file(s)
     *
     * @param UrlInterface|array|string $urls
     * @param bool                      $prefix If true, the scripts will be added at the beginning of the scripts list
     *
     * @return void
     */
    public static function loadCss(UrlInterface|array|string $urls, bool $prefix = false): void
    {
        $scripts = [];

        // Convert the given URL (parts) to real URLs
        foreach (Arrays::force($urls, '') as $url) {
            $url           = Strings::ensureEndsNotWith($url, '.css');
            $url           = Strings::ensureEndsNotWith($url, '.min');
            $url           = static::versionFile($url, 'css');
            $scripts[$url] = [
                'rel'  => 'stylesheet',
                'href' => Url::getCss($url),
            ];
        }

        if ($prefix) {
            static::$page_headers['link'] = array_merge($scripts, static::$page_headers['link']);

        } else {
            static::$page_headers['link'] = array_merge(static::$page_headers['link'], $scripts);
        }
    }


    /**
     * Add the specified HTML to the footer
     *
     * @param array|string|null $entry
     * @param string            $key
     *
     * @return void
     * @todo This should -in the near future- be updated to sending Javascript, Css, etc objects instead of "some array"
     *
     */
    public static function addToFooter(array|string|null $entry, string $key = 'html'): void
    {
        static::$page_footers[$key][] = $entry;
    }


    /**
     * Builds and return the HTML <head> tag
     *
     * @return string|null
     */
    public static function renderHtmlHeaders(): ?string
    {
        static::$html_headers_sent = true;

        $return = '<!DOCTYPE ' . static::$doctype . '>
        <html lang="' . Session::getLanguage() . '">' . PHP_EOL;

        if (static::getPageTitle()) {
            $return .= '<title>' . (Core::isProductionEnvironment() ? null : '(' . ENVIRONMENT . ') ') . static::$page_title . '</title>' . PHP_EOL;
        }

        foreach (static::$page_headers['meta'] as $key => $value) {
            $return .= '<meta name="' . $key . '" content="' . $value . '" />' . PHP_EOL;
        }

        foreach (static::$page_headers['link'] as $header) {
            $header = Arrays::implodeWithKeys($header, ' ', '=', '"');
            $return .= '<link ' . $header . ' />' . PHP_EOL;
        }

        foreach (static::$page_headers['javascript'] as $header) {
            $header = Arrays::implodeWithKeys($header, ' ', '=', '"');
            $return .= '<script ' . $header . '></script>' . PHP_EOL;
        }

        return $return . '</head>';
    }


    /**
     * Returns the language used for this page
     *
     * @return LanguageInterface
     */
    public static function getLanguage(): LanguageInterface
    {
        if (empty(static::$language_code)) {
            static::$language = Language::load(static::getLanguageCode());
        }

        return static::$language;
    }


    /**
     * Returns the language used for this page in ISO 639-2-b format
     *
     * @return string
     */
    public static function getLanguageCode(): string
    {
        if (empty(static::$language)) {
            if (PLATFORM_WEB) {
                // Get requested language
                static::$language_code = Request::detectRequestedLanguage();

            } else {
                // Get requested language from core
                static::$language_code = Core::readRegister('system', 'language');
            }
        }

        return static::$language_code;
    }


    /**
     * Returns the browser page title
     *
     * @return string
     */
    public static function getPageTitle(): string
    {
        return static::$page_title;
    }


    /**
     * Sets the browser page title
     *
     * @param Stringable|string|float|int|null $page_title
     * @param bool                             $force
     *
     * @return void
     */
    public static function setPageTitle(Stringable|string|float|int|null $page_title, bool $force = true): void
    {
        if (empty(static::$page_title) or $force) {
            static::$page_title = get_null(strip_tags((string) $page_title));
        }
    }


    /**
     * Build and return the HTML page_footers
     *
     * @return string|null
     * @todo This should be upgraded to using Javascript / Css objects
     */
    public static function renderHtmlFooters(): ?string
    {
        Log::warning('TODO Reminder: static::buildFooters() should be upgraded to using Javascript / Css objects');

        $return = '';

        if (isset_get(static::$page_footers['html'])) {
            $return .= implode('', static::$page_footers['html']);
        }

        foreach (static::$page_footers['javascript'] as $footer) {
            if (isset($footer['src'])) {
                $footer = Arrays::implodeWithKeys($footer, ' ', '=', '"');
                $return .= '<script ' . $footer . '></script>' . PHP_EOL;

            } elseif (isset($footer['content'])) {
                if ($footer['content'] instanceof ScriptInterface) {
                    $footer['content']->setAttach(EnumAttachJavascript::here)->render();
                }

                $return .= $footer['content'] . PHP_EOL;

            } else {
                throw new OutOfBoundsException(tr('Invalid script footer specified, should contain at least "src" or "content"'));
            }
        }

        return $return;
    }


    /**
     * Check if this user should be forcibly being redirected to a different page
     *
     * @return void
     */
    public static function checkForceRedirect(): void
    {
        // Does this user have a forced redirect?
        if (!Session::getUserObject()->isGuest()) {
            $redirect = Session::getUserObject()->getRedirect();

            if ($redirect) {
                // Are we at the forced redirect page? If so, we can stay
                $current = (string) Url::getCurrent();

                if (Strings::until($redirect, '?') !== Strings::until($current, '?')) {
                    // We're at a different page. Should we redirect to the specified page?
                    if (!static::skipRedirect()) {
                        // No, it's not, redirect!
                        Log::action(tr('User ":user" has a redirect to ":url", redirecting there instead', [
                            ':user' => Session::getUserObject()
                                              ->getLogId(),
                            ':url'  => $redirect,
                        ]));

                        // Get URL builder object, ensure that sign-in page gets a redirect=$current_url
                        $redirect = Url::getWww($redirect);

                        if ((string) $redirect === (string) Url::getWww('sign-in')) {
                            $redirect->addQueries('redirect=' . $current);
                        }

                        static::redirect($redirect);
                    }

                    Log::warning(tr('User ":user" has a redirect to ":url" which MAY NOT redirected to, ignoring redirect', [
                        ':user' => Session::getUserObject()
                                          ->getLogId(),
                        ':url'  => $redirect,
                    ]));
                }
            }
        }
    }


    /*
     * Test HTTP caching headers
     *
     * Sends out 304 - Not modified header if ETag matches
     *
     * For more information, see https://developers.google.com/speed/docs/insights/LeverageBrowserCaching
     * and https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching
     */
    /**
     * Returns the redirect URL if it should not be skipped
     *
     * @param Stringable|string $redirect
     *
     * @return string|null
     */
    public static function getRedirect(Stringable|string $redirect): ?string
    {
        if (static::skipRedirect($redirect)) {
            Log::warning(tr('Skipping redirect to ":redirect" as it is now allowed', [
                ':redirect' => $redirect,
            ]));

            return null;
        }

        return (string) $redirect;
    }


    /*
     * Test HTTP caching headers
     *
     * Sends out 304 - Not modified header if ETag matches
     *
     * For more information, see https://developers.google.com/speed/docs/insights/LeverageBrowserCaching
     * and https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching
     */
    /**
     * Returns true if redirecting for the specified URL should be skipped
     *
     * Currently, sign-out or index pages should not be redirected to
     *
     * @param Stringable|string|null $url
     *
     * @return bool
     */
    protected static function skipRedirect(Stringable|string|null $url = null): bool
    {
        if (!$url) {
            // Default to current URL
            $url = Url::getCurrent();
        }

        // Compare URLs without queries
        $url  = Strings::until((string) $url, '?');
        $skip = [
            (string) Url::getWww('sign-out'),
        ];

        return in_array($url, $skip);
    }


    /**
     * Signs the user out of the session and optionally redirects
     *
     * @param UrlInterface|string|null $redirect
     *
     * @return void
     */
    public static function signOut(UrlInterface|string|null $redirect = 'signin'): void
    {
        Session::signOut();

        if ($redirect) {
            static::redirect($redirect);
        }
    }


    /**
     * Return the specified URL with a redirect URL stored in $core->register['redirect']
     *
     * @note If no URL is specified, the current URL will be used
     *
     * @param UrlInterface|string|bool|null $url
     * @param int                           $http_code
     * @param int|null                      $time_delay
     * @param string|null                   $reason_warning
     *
     * @return never
     * @see  Url
     * @see  Url::addQueries()
     */
    #[NoReturn] public static function redirect(UrlInterface|string|bool|null $url = null, int $http_code = 302, ?int $time_delay = null, ?string $reason_warning = null): never
    {
        if (!PLATFORM_WEB) {
            throw new ResponseRedirectException(tr('Response::redirect() can only be called on web sessions'));
        }

        //        if (Session::getSignInKey()?->getAllowNavigation()) {
        //            // This session was opened using a sign-in key that does not allow navigation, we cannot target away!
        //            throw new RedirectException(tr('Cannot target sign-in session with UUID ":uuid" for user ":user" to URL ":url", this session does not allow navigation', [
        //                ':uuid' => Session::getSignInKey()->getUuid(),
        //                ':user' => Session::getUser()->getLogId(),
        //                ':url'  => $url
        //            ]));
        //        }
        // Build URL
        $target = Url::getWww($url);

        // Protect against endless redirecting.
        if (Url::isCurrent($target)) {
            // POST-requests may target to the same page as the target will change POST to GET
            if (!Request::isPostRequestMethod()) {
                // If the specified target URL was a short code like "prev" or "referer", then it was not hard coded
                // and the system couldn't know that the short code is the same as the current URL. Redirect to domain
                // root instead
                switch ($url) {
                    case 'prev':
                        // no break;

                    case 'previous':
                        // no break;

                    case 'referer':
                        $target = Url::getCurrentDomainRootUrl();
                        break;

                    default:
                        if (!Session::userChanged()) {
                            // Redirecting to the same page for the same user may cause an endless redirect loop
                            throw new OutOfBoundsException(tr('Will NOT redirect to ":url", its the same URL as the current page and the current request method is not POST', [
                                ':url' => $target,
                            ]));
                        }

                        $target = Url::getCurrentDomainRootUrl();
                };
            }
        }

        if (isset_get($_GET['target'])) {
            // Add a target back query
            $target = Url::getWww($target)->addQueries(['target' => $_GET['target']]);
        }

        /*
         * Validate the specified http_code, must be one of
         *
         * 301 Moved Permanently
         * 302 Found
         * 303 See Other
         * 307 Temporary Redirect
         */
        switch ($http_code) {
            case 301:
                // no break
            case 302:
                // no break
            case 303:
                // no break
            case 307:
                // All valid
            case 401:
                // All valid
                break;
            default:
                throw new OutOfBoundsException(tr('Invalid HTTP code ":code" specified', [
                    ':code' => $http_code,
                ]));
        }

        static::setHttpCode($http_code);

        if ($reason_warning) {
            Log::warning(tr('Redirecting because: :reason', [':reason' => $reason_warning]));
        }

        // Redirect with time delay
        if ($time_delay) {
            Log::action(tr('Redirecting with HTTP ":http" and ":time" seconds delay to url ":url"', [
                ':http' => $http_code,
                ':time' => $time_delay,
                ':url'  => $target,
            ]));

            Response::setHttpCode($http_code);
            header('Refresh: ' . $time_delay . ';' . $target, true, $http_code);

        } else {
            // Redirect immediately
            Log::action(tr('Redirecting with HTTP ":http" to url ":url"', [
                ':http' => $http_code,
                ':url'  => $target,
            ]));

            Response::setHttpCode($http_code);
            header('Location:' . $target, true, $http_code);
        }

        exit();
    }


    protected static function cacheTest($etag = null): bool
    {
        static::$etag = sha1(PROJECT . $_SERVER['SCRIPT_FILENAME'] . filemtime($_SERVER['SCRIPT_FILENAME']) . $etag);
        if (!Config::get('web.cache.enabled', 'auto')) {
            return false;
        }
        if (Request::isRequestType(EnumRequestTypes::ajax) or Request::isRequestType(EnumRequestTypes::api)) {
            return false;
        }
        if ((strtotime(isset_get($_SERVER['HTTP_IF_MODIFIED_SINCE'])) == filemtime($_SERVER['SCRIPT_FILENAME'])) or trim(isset_get($_SERVER['HTTP_IF_NONE_MATCH']), '') == static::$etag) {
            if (empty($core->register['flash'])) {
                // The client sent an etag which is still valid, no body (or anything else) necesary
                static::setHttpCode(304);
                static::sendHttpHeaders();
                exit();
            }
        }

        return true;
    }


    /**
     * Send all the specified HTTP headers
     *
     * @note The number of sent bytes does NOT include the bytes sent for the HTTP response code header
     * @return int The number of bytes sent. -1 if static::sendHeaders() was called for the second time.
     * @throws PageNotFoundException
     */
    protected static function sendHttpHeaders(): int
    {
        if (static::httpHeadersSent(true)) {
            // Headers already sent
            return -1;
        }
        if (empty(static::$http_headers)) {
            // Specified NULL for headers, which is what buildHeaders() returned, so there are no headers to send
            return -1;
        }
        try {
            $length = 0;
            // Set correct headers
            http_response_code(static::$http_code);
            // Send all available headers
            foreach (static::$http_headers as $header) {
                $length += strlen($header);
                header($header);
            }
            switch (static::getHttpCode()) {
                case 200:
                    // no break
                case 301:
                    // no break
                case 302:
                    // no break
                case 304:
                    Log::success(tr('Sent HTTP headers with HTTP code ":http" using ":length" bytes', [
                        ':length' => number_format($length),
                        ':http'   => (static::$http_code ? 'HTTP ' . static::$http_code : 'HTTP 0'),
                    ]), 4);
                    break;
                default:
                    Log::warning(tr('Sent HTTP headers with HTTP code ":http" using ":length" bytes', [
                        ':length' => number_format($length),
                        ':http'   => (static::$http_code ? 'HTTP ' . static::$http_code : 'HTTP 0'),
                    ]));
            }
            static::$bytes_sent += $length;

            return $length;

        } catch (Throwable $e) {
            Notification::new()
                        ->setException($e)
                        ->setTitle(tr('Failed to send headers to client'))
                        ->send();
            // static::sendHeaders() itself crashed. Since static::sendHeaders() would send out http 500, and since it
            // crashed, it no longer can do this, send out the http 500 here.
            try {
                http_response_code(500);

            } catch (Throwable) {
                // Yeah, we can't set HTTP code either, body probably has already been sent then.
            }
            throw new ResponseHeadersException(tr('Failed to send HTTP headers'), $e);
        }
    }


    /**
     * Checks if HTTP headers have already been sent and logs warnings if so
     *
     * @param bool $sending_now
     *
     * @return bool
     */
    protected static function httpHeadersSent(bool $sending_now = false): bool
    {
        if (headers_sent($file, $line)) {
            return true;
        }
        if (static::$http_headers_sent) {
            return true;
        }
        if ($sending_now) {
            static::$http_headers_sent = true;
        }

        return false;
    }


    /**
     * Returns the status code that will be sent to the client
     *
     * @return int
     */
    public static function getHttpCode(): int
    {
        return static::$http_code;
    }


    /**
     * Sets the status code that will be sent to the client
     *
     * @param int $code
     *
     * @return void
     */
    public static function setHttpCode(int $code): void
    {
        if (!$code) {
            if (static::$http_code) {
                // HTTP code was set, no code specified. Ignore this request
                return;
            }
        }

        // Validate status code
        // TODO implement


        static::$http_code = $code;
    }


    /**
     * Send the current buffer to the client
     *
     * @param bool $exit
     *
     * @return void
     */
    public static function send(bool $exit = true): void
    {
        if (PLATFORM_WEB) {
            if (isset(static::$page_headers)) {
                // Only cache if there are headers. If static::buildHeaders() returned null this means that the headers
                // have already been sent before, probably by a debugging function like Debug::show(). DON'T CACHE!
                Cache::write([
                    'output'  => static::getOutput(false),
                    'headers' => static::$page_headers,
                ], 'WebResponse ' . Request::getUri());

                $length = static::sendHttpHeaders();

                Log::success(tr('Cached ":length" bytes of HTTP to client', [':length' => $length]), 3);
            }

            // Filter output out for certain HTTP codes, then send headers & output
            static::clearOutputForHttpCodesAndMethods();
            static::generateHttpHeaders();
            static::sendHttpHeaders();
            static::sendOutput();
        }

        if ($exit) {
            exit();
        }
    }


    /**
     * Returns the current HTML output buffer for this page
     *
     * @param bool $clear
     *
     * @return string|null
     */
    public static function getOutput(bool $clear = true): ?string
    {
        if (ob_get_length()) {
            if ($clear) {
                return ob_get_clean();
            }

            return ob_get_contents();
        }

        // Output buffer is disabled or empty
        return null;
    }


    /**
     * Sets the output generated by the request
     *
     * @param string|null $output
     *
     * @return void
     */
    public static function setOutput(?string $output): void
    {
        ob_clean();
        static::addOutput($output);
    }


    /**
     * Returns NULL output if the request method was HEAD (don't return output, only headers)
     *
     * @return void
     */
    protected static function clearOutputForHttpCodesAndMethods(): void
    {
        // 304 requests indicate the browser to use its local cache, send nothing
        // 429 Tell the client that it made too many requests, send nothing
        switch (static::getHttpCode()) {
            case 304:
                // no break
            case 429:
                static::clean();
                break;

            default:
                if (strtoupper($_SERVER['REQUEST_METHOD']) === 'HEAD') {
                    // HEAD request; do not send any HTML whatsoever
                    static::clean();
                }
        }
    }


    /**
     * Cleans the response output buffer
     *
     * @return void
     */
    public static function clean(): void
    {
        ob_clean();
    }


    /**
     * Builds and returns all the HTTP headers
     *
     * @todo Rewrite this crap
     * @return array|null
     */
    protected static function generateHttpHeaders(): ?array
    {
        if (static::httpHeadersSent()) {
            return null;
        }

        $headers = [];

        // Remove incorrect or insecure headers
        header_remove('Expires');
        header_remove('Pragma');

        /*
         * Ensure that from this point on we have a language configuration available
         *
         * The startup systems already configures languages but if the startup itself fails, or if a show() or showdie()
         * was issued before the startup finished, then this could leave the system without defined language
         */
        if (!defined('LANGUAGE')) {
            define('LANGUAGE', Config::get('http.language.default', 'en'));
        }

        // Create ETAG, possibly send out HTTP304 if the client sent matching ETAG
        static::cacheEtag();

        // What to do with the PHP signature?
        switch (Core::getExposePhp()) {
            case 'limited':
                $headers[] = 'X-Powered-By: PHP';
                break;

            case 'full':
                $headers[] = 'X-Powered-By: PHP/' . phpversion();
                break;

            case 'fake':
                $headers[] = 'X-Powered-By: PHP/7.1.2';
                break;

            case 'none':
                // Remove the PHP signature
                header_remove('X-Powered-By');
                break;
        }

        // Add a powered-by header
        switch (Core::getExposePhoundation()) {
            case 'limited':
                header('Powered-By-Framework: Phoundation');
                break;

            case 'full':
                header(tr('Powered-By-Framework: Phoundation/:version"', [
                    ':version' => Core::FRAMEWORK_CODE_VERSION,
                ]));
                break;

            case 'fake':
                header(tr('Powered-By-Framework: Phoundation/:version"', [
                    ':version' => '4.11.1',
                ]));
        }

        $headers[] = 'Content-Type: ' . static::$content_type . '; charset=' . Config::get('languages.encoding.charset', 'UTF-8');
        $headers[] = 'Content-Language: ' . LANGUAGE;
        $headers[] = 'Content-Length: ' . ob_get_length();

        if (static::$http_code == 200) {
            if (empty($params['last_modified'])) {
                $headers[] = 'Last-Modified: ' . Date::convert(filemtime($_SERVER['SCRIPT_FILENAME']), 'D, d M Y H:i:s', 'GMT') . ' GMT';

            } else {
                $headers[] = 'Last-Modified: ' . Date::convert($params['last_modified'], 'D, d M Y H:i:s', 'GMT') . ' GMT';
            }
        }

        // Add noindex, nofollow and nosnipped headers for non production environments and non normal HTTP pages.
        // These pages should NEVER be indexed
        if (!Core::isProductionEnvironment() or !Request::isRequestType(EnumRequestTypes::html) or Config::get('web.noindex', false)) {
            $headers[] = 'X-Robots-Tag: noindex, nofollow, nosnippet, noarchive, noydir';
        }

        // CORS headers
        if (Config::get('web.security.cors', true) or static::$cors) {
            // Add CORS / Access-Control-Allow-.... headers
            // TODO This will cause issues if configured web.cors is not an array!
            static::$cors = array_merge(Arrays::force(Config::get('web.cors', [])), static::$cors);

            foreach (static::$cors as $key => $value) {
                switch ($key) {
                    case 'origin':
                        if ($value == '*.') {
                            // Origin is allowed from all subdomains
                            $origin = Strings::from(isset_get($_SERVER['HTTP_ORIGIN']), '://');
                            $length = strlen(isset_get($_SESSION['domain']));
                            if (substr($origin, -$length, $length) === isset_get($_SESSION['domain'])) {
                                // Sub domain matches. Since CORS does not support sub domains, just show the
                                // current sub domain.
                                $value = $_SERVER['HTTP_ORIGIN'];

                            } else {
                                // Sub domain does not match. Since CORS does not support sub domains, just show no
                                // allowed origin domain at all
                                $value = '';
                            }
                        }
                    // no break
                    case 'methods':
                        // no break
                    case 'headers':
                        if ($value) {
                            $headers[] = 'Access-Control-Allow-' . Strings::capitalize($key) . ': ' . $value;
                        }
                        break;
                    default:
                        throw new HttpException(tr('Unknown CORS header ":header" specified', [
                            ':header' => $key,
                        ]));
                }
            }
        }

        // Add cache headers and store headers in the object headers list
        return static::addHttpCacheHeaders($headers);
    }


    protected static function cacheEtag(): bool
    {
        // ETAG requires HTTP caching enabled. Ajax and API calls do not use ETAG
        if (!Config::get('web.cache.enabled', 'auto') or Request::isRequestType(EnumRequestTypes::ajax) or Request::isRequestType(EnumRequestTypes::api)) {
            static::$etag = null;

            return false;
        }

        // Create local ETAG
        static::$etag = sha1(PROJECT . $_SERVER['SCRIPT_FILENAME'] . filemtime($_SERVER['SCRIPT_FILENAME']) . Core::readRegister('etag'));

        // :TODO: Document why we are trimming with an empty character mask... It doesn't make sense but something tells me we're doing this for a good reason...
        if (trim((string) isset_get($_SERVER['HTTP_IF_NONE_MATCH']), '') == static::$etag) {
            if (empty($core->register['flash'])) {
                // The client sent an etag which is still valid, no body (or anything else) necessary
                http_response_code(304);
                exit();
            }
        }

        return true;
    }


    /**
     * Adds caching headers to the specified HTTP headers and returns the list
     *
     * Returns headers Cache-Control and ETag
     *
     * @param array $headers Any extra headers that are required
     *
     * @return array
     * @author    Sven Olaf Oostenbrink <so.oostenbrink@gmail.com>
     * @copyright Copyright (c) 2022 Sven Olaf Oostenbrink
     * @license   http://opensource.org/licenses/GPL-2.0 GNU Public License, Version 2
         * @package   http
     * @see       htt_noCache()
     * @see       https://developers.google.com/speed/docs/insights/LeverageBrowserCaching
     * @see       https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching
     * @version   2.5.92: Added function and documentation
     */
    protected static function addHttpCacheHeaders(array $headers): array
    {
        if (Config::get('web.cache.enabled', 'auto') === 'auto') {
            // PHP will take care of the cache headers
            return $headers;
        }

        if (Config::get('web.cache.enabled', 'auto') === true) {
            // Place headers using phoundation algorithms
            if (!Config::get('web.cache.enabled', 'auto') or (static::$http_code != 200)) {
                // Non HTTP 200 / 304 pages should NOT have cache enabled! For example, 404, 503 etc...
                $headers[]    = 'Cache-Control: no-store, max-age=0';
                static::$etag = null;

            } else {
                // Send caching headers. Ajax, API, and admin calls do not have proxy caching
                switch (Request::getRequestType()) {
                    case EnumRequestTypes::api:
                        // no break

                    case EnumRequestTypes::ajax:
                        // no break

                    case EnumRequestTypes::admin:
                        break;

                    default:
                        // Session pages for specific users should not be stored on proxy servers either
                        if (!empty($_SESSION['user']['id'])) {
                            Config::get('web.cache.cacheability', 'private');
                        }

                        $headers[] = 'Cache-Control: ' . Config::get('web.cache.cacheability', 'private') . ', ' . Config::get('web.cache.expiration', 'max-age=604800') . ', ' . Config::get('web.cache.revalidation', 'must-revalidate') . Config::get('web.cache.other', 'no-transform');

                        if (!empty(static::$etag)) {
                            $headers[] = 'ETag: "' . static::$etag . '"';
                        }
                }
            }
        }

        return $headers;
    }


    /**
     * Send the generated page output to the client
     *
     * @return void
     */
    protected static function sendOutput(): void
    {
        if (Request::getAttachment()) {
            // Send download headers and send the $html payload
            FileResponse::new(Request::getTarget(), FsRestrictions::getWeb())
                        ->setAttachment(true)
                        ->setData(static::getOutput())
                        ->setFilename(basename(Request::getTarget()->getSource()))
                        ->send();
        }

        // Track data sizes
        $length             = static::getOutputLength();
        static::$bytes_sent += $length;

        // Send the page to the client
        echo static::getOutput();

        // Log how much we sent
        if ($length) {
            Log::action(tr('Sent ":length" output data to client', [
                ':length' => Numbers::getHumanReadableBytes($length),
            ]), 4);
        } else {
            Log::warning(tr('Warning: page generated no output for client, sent 0 bytes'));
        }
    }


    /**
     * Kill this web page script process
     *
     * @note Even if $exit_message was specified, the normal shutdown functions will still be called
     *
     * @param string|null $exit_message If specified, this message will be displayed and the process will be terminated
     * @param bool        $sig_kill
     *
     * @return never
     * @todo Implement this and add required functionality
     */
    #[NoReturn] public static function exit(?string $exit_message = null, bool $sig_kill = false): never
    {
        // If something went really, really wrong...
        if ($sig_kill) {
            exit($exit_message);
        }

        // POST-requests should always show a flash message for feedback!
        if (Request::isPostRequestMethod()) {
            if (!Response::getFlashMessagesObject()->getCount()) {
                Log::warning('Detected POST request without a flash message to give user feedback on what happened with this request!');
            }
        }

        switch (Response::getHttpCode()) {
            case 200:
                // no break
            case 301:
                // no break
            case 302:
                // no break
            case 304:
                if ($exit_message) {
                    Log::success($exit_message);
                }

                Log::success(tr('Script(s) ":script" ended successfully with HTTP code ":http_code", sending ":sent" to client in ":time" with ":usage" peak memory usage', [
                    ':script'    => Request::getExecutedPath(true),
                    ':time'      => Time::difference(STARTTIME, microtime(true), 'auto', 5),
                    ':usage'     => Numbers::getHumanReadableBytes(memory_get_peak_usage()),
                    ':http_code' => Response::getHttpCode(),
                    ':sent'      => Numbers::getHumanReadableBytes(Response::getBytesSent()),
                ]));
                break;

            default:
                if ($exit_message) {
                    Log::error($exit_message);
                }

                Log::error(tr('Script(s) ":script" ended with HTTP warning code ":http_code", sending ":sent" to client  in ":time" with ":usage" peak memory usage', [
                    ':script'    => Request::getExecutedPath(true),
                    ':time'      => Time::difference(STARTTIME, microtime(true), 'auto', 5),
                    ':usage'     => Numbers::getHumanReadableBytes(memory_get_peak_usage()),
                    ':http_code' => Response::getHttpCode(),
                    ':sent'      => Numbers::getHumanReadableBytes(Response::getBytesSent()),
                ]));
        }

        InstanceCache::logStatistics();

        // Remove subprocess run directory
        Process::deleteRunDirectory();

        // Normal kill request
        Log::action(tr('Killing web page process'), 2);
        exit();
    }


    /**
     * Returns the current length HTML output buffer for this page
     *
     * @return int
     */
    public static function getOutputLength(): int
    {
        return (int) ob_get_length();
    }


    /**
     * Adds output generated by the request to the (possibly already existing) current output
     *
     * @param string|null $output
     *
     * @return void
     */
    public static function addOutput(?string $output): void
    {
        echo $output;
    }


    /**
     * Returns if only the main contents should be rendered, or the entire page
     *
     * @return bool
     */
    public static function getRenderMainContentsOnly(): bool
    {
        return static::$render_main_contents_only;
    }


    /**
     * Sets if only the main contents should be rendered, or the entire page
     *
     * @param bool $render_main_contents_only
     *
     * @return void
     */
    public static function setRenderMainContentsOnly(bool $render_main_contents_only): void
    {
        static::$render_main_contents_only = $render_main_contents_only;
    }


    /**
     * Send the required headers to ensure that the page will not be cached ever
     *
     * @return void
     * @copyright Copyright (c) 2022 Sven Olaf Oostenbrink
     * @license   http://opensource.org/licenses/GPL-2.0 GNU Public License, Version 2
         * @package   http
     * @see       Http::cache()
     * @version   2.5.92: Added function and documentation
     * @author    Sven Olaf Oostenbrink <so.oostenbrink@gmail.com>
     */
    protected static function sendNoCacheHttpHeaders(): void
    {
        header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0', true);
        header('Cache-Control: post-check=0, pre-check=0', true);
        header('Pragma: no-cache', true);
        header('Expires: Wed, 10 Jan 2000 07:00:00 GMT', true);
    }


    /**
     * Adds the specified script to the rendered output
     *
     * @param ScriptInterface|string $script
     * @param EnumJavascriptWrappers $wrapper
     * @param EnumAttachJavascript   $attach
     *
     * @return ScriptInterface
     */
    public static function addScript(ScriptInterface|string $script, EnumJavascriptWrappers $wrapper = EnumJavascriptWrappers::dom_content, EnumAttachJavascript $attach = EnumAttachJavascript::footer): ScriptInterface
    {
        if (is_string($script)) {
            $script = new Script($script);
        }

        return $script->setJavascriptWrapper($wrapper)
                      ->setAttach($attach)
                      ->attach();
    }


    /**
     * Returns the upload handlers object for this response
     *
     * @return UploadHandlersInterface
     */
    public static function getFileUploadHandlersObject(): UploadHandlersInterface
    {
        return Request::getFileUploadHandlersObject();
    }
}
