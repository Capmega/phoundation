<?php

declare(strict_types=1);

namespace Phoundation\Data\DataEntry;

use Phoundation\Cli\Cli;
use Phoundation\Core\Arrays;
use Phoundation\Core\Strings;
use Phoundation\Data\DataEntry\Interfaces\DataEntryInterface;
use Phoundation\Data\DataEntry\Interfaces\DataListInterface;
use Phoundation\Data\Iterator;
use Phoundation\Data\Traits\DataParent;
use Phoundation\Databases\Sql\Interfaces\QueryBuilderInterface;
use Phoundation\Databases\Sql\QueryBuilder;
use Phoundation\Databases\Sql\Sql;
use Phoundation\Exception\OutOfBoundsException;
use Phoundation\Utils\Json;
use Phoundation\Web\Http\Html\Components\DataTable;
use Phoundation\Web\Http\Html\Components\Input\Interfaces\SelectInterface;
use Phoundation\Web\Http\Html\Components\Input\InputSelect;
use Phoundation\Web\Http\Html\Components\Table;
use ReturnTypeWillChange;
use Stringable;


/**
 * Class DataList
 *
 *
 *
 * @author Sven Olaf Oostenbrink <so.oostenbrink@gmail.com>
 * @license http://opensource.org/licenses/GPL-2.0 GNU Public License, Version 2
 * @copyright Copyright (c) 2023 Sven Olaf Oostenbrink <so.oostenbrink@gmail.com>
 * @package Company\Data
 */
abstract class DataList extends Iterator implements DataListInterface
{
    use DataParent;


    /**
     * The iterator position
     *
     * @var int $position
     */
    protected int $position = 0;

    /**
     * The query to display an HTML table for this list
     *
     * @var string $query
     */
    protected string $query;

    /**
     * The execution array for the HTML query
     *
     * @var array|null $execute
     */
    protected ?array $execute;


    /**
     * If set, use the query generated by this builder instead of the default query
     *
     * @var QueryBuilderInterface
     */
    protected QueryBuilderInterface $query_builder;

    /**
     * If true it means that this data list has data loaded from a database
     *
     * @var bool $is_loaded
     */
    protected bool $is_loaded = false;


    /**
     * Return the object source contents in JSON string format
     *
     * @return string
     */
    public function __toString(): string
    {
        return Json::encode($this->source);
    }


    /**
     * Return the object contents in JSON string format
     *
     * @return array
     */
    public function __toArray(): array
    {
        return $this->source;
    }


    /**
     * Iterator class constructor
     */
    public function __construct()
    {
        parent::__construct();
    }


    /**
     * Returns a new Iterator object
     */
    public static function new(): static
    {
        return new static();
    }


    /**
     * Returns the table name used by this object
     *
     * @return string
     */
    abstract public static function getTable(): string;


    /**
     * Returns the name of this DataEntry class
     *
     * @return string
     */
    abstract public static function getEntryClass(): string;


    /**
     * Returns the field that is unique for this object
     *
     * @return string|null
     */
    abstract public static function getUniqueField(): ?string;


    /**
     * Returns if the specified data entry exists in the data list
     *
     * @param DataEntryInterface|Stringable|string|float|int $key
     * @return bool
     */
    public function exists(DataEntryInterface|Stringable|string|float|int $key): bool
    {
        if ($key instanceof DataEntryInterface) {
            $key = $key->getId();
        }

        return parent::exists($key);
    }


    /**
     * Returns a list of items that are specified, but not available in this DataList
     *
     * @param DataListInterface|array|string $list
     * @param string|null $always_match
     * @return array
     */
    public function getMissingKeys(DataListInterface|array|string $list, string $always_match = null): array
    {
        if (is_string($list)) {
            $list = explode(',', $list);
        }

        $return = [];

        foreach ($list as $entry) {
            if (array_key_exists($entry, $this->source)) {
                continue;
            }

            // Can still match if $always_match is available!
            if ($always_match and array_key_exists($always_match, $this->source)) {
                // Okay, this list contains ALL the requested entries due to $always_match
                return [];
            }

            $return[] = $entry;
        }

        return $return;
    }


    /**
     * Returns if all (or optionally any) of the specified entries are in this list
     *
     * @param DataListInterface|array|string $list
     * @param bool $all
     * @param string|null $always_match
     * @return bool
     */
    public function containsKeys(DataListInterface|array|string $list, bool $all = true, string $always_match = null): bool
    {
        if (is_string($list)) {
            $list = explode(',', $list);
        }

        foreach ($list as $entry) {
            if (!array_key_exists($entry, $this->source)) {
                if ($all) {
                    // All need to be in the array, but we found one missing.
                    // Can still match if $always_match is available!
                    if ($always_match and array_key_exists($always_match, $this->source)) {
                        // Okay, this list contains ALL the requested entries due to $always_match
                        return true;
                    }

                    return false;
                }
            } else {
                if (!$all) {
                    // only one needs to be in the array, we found one, we're good!
                    return true;
                }
            }
        }

        // All were in the array
        return true;
    }


    /**
     * Returns if all (or optionally any) of the specified entries are in this list
     *
     * @param DataListInterface|array|string $list
     * @param bool $all
     * @param string|null $always_match
     * @return bool
     */
    public function containsValues(DataListInterface|array|string $list, bool $all = true, string $always_match = null): bool
    {
        if (is_string($list)) {
            $list = explode(',', $list);
        }

        foreach ($list as $entry) {
            if (!in_array($entry, $this->source)) {
                if ($all) {
                    // All need to be in the array, but we found one missing.
                    // Can still match if $always_match is available!
                    if ($always_match and in_array($always_match, $this->source)) {
                        // Okay, this list contains ALL the requested entries due to $always_match
                        return true;
                    }

                    return false;
                }
            } else {
                if (!$all) {
                    // only one needs to be in the array, we found one, we're good!
                    return true;
                }
            }
        }

        // All were in the array
        return true;
    }


    /**
     * Returns the internal list filtered by the specified keyword
     *
     * @param string|null $keyword
     * @return array
     */
    public function filteredList(?string $keyword): array
    {
        $return = [];
        $keyword = strtolower((string) $keyword);

        foreach ($this->getSource() as $value) {
            if (!$keyword or str_contains(strtolower(trim($value)), $keyword)) {
                $return[] = $value;
            }
        }

        return $return;
    }


    /**
     * Set the query for this object when generating internal content
     *
     * @param string $query
     * @param array|null $execute
     * @return static
     */
    public function setQuery(string $query, ?array $execute = null): static
    {
        $this->query   = $query;
        $this->execute = $execute;

        return $this;
    }


    /**
     * Returns the query for this object when generating internal content
     *
     * @return string
     */
    public function getQuery(): string
    {
        $this->selectQuery();
        return $this->query;
    }


    /**
     * Returns the execute array for the query for this object when generating internal content
     *
     * @return array|null
     */
    public function getExecute(): ?array
    {
        $this->selectQuery();
        return $this->execute;
    }


    /**
     * Returns the schema Table object for the table that is the source for this DataList object
     *
     * @return \Phoundation\Databases\Sql\Schema\Table
     */
    public function getTableSchema(): \Phoundation\Databases\Sql\Schema\Table
    {
        return sql()->schema()->table(static::getTable());
    }


    /**
     * Returns the item with the specified identifier
     *
     * @param Stringable|string|float|int $key
     * @param bool $exception
     * @return DataEntry|null
     */
    #[ReturnTypeWillChange] public function get(Stringable|string|float|int $key, bool $exception = false): ?DataEntryInterface
    {
        // Does this entry exist?
        if (!array_key_exists($key, $this->source)) {
            throw new OutOfBoundsException(tr('Key ":key" does not exist in this DataList', [
                ':key' => $key
            ]));
        }

        return $this->ensureDataEntry($key);
    }


    /**
     * Returns a QueryBuilder object to modify the internal query for this object
     *
     * @return QueryBuilderInterface
     */
    public function getQueryBuilder(): QueryBuilderInterface
    {
        if (!isset($this->query_builder)) {
            $this->query_builder = new QueryBuilder($this);
        }

        return $this->query_builder;
    }


    /**
     * Creates and returns an HTML table for the data in this list
     *
     * @return Table
     */
    public function getHtmlTable(): Table
    {
        $this->selectQuery();

        // Create and return the table
        return Table::new()
            ->setSourceQuery($this->query, $this->execute)
            ->setCallbacks($this->callbacks)
            ->setCheckboxSelectors(true);
    }


    /**
     * Creates and returns a fancy HTML data table for the data in this list
     *
     * @return DataTable
     */
    public function getHtmlDataTable(array|string|null $columns = null): DataTable
    {
        if ($this->source) {
            // Source is already loaded, use this instead
            // Create and return the table
            return DataTable::new()
                ->setId(static::getTable())
                ->setSource($this->getSourceColumns($columns))
                ->setCallbacks($this->callbacks)
                ->setCheckboxSelectors(true);

        }

        $this->selectQuery();

        // Create and return the table
        return DataTable::new()
            ->setId(static::getTable())
            ->setSourceQuery($this->query, $this->execute)
            ->setCallbacks($this->callbacks)
            ->setCheckboxSelectors(true);
    }


    /**
     * Returns an HTML <select> for the available object entries
     *
     * @param string $value_column
     * @param string $key_column
     * @param string|null $order
     * @return SelectInterface
     */
    public function getHtmlSelect(string $value_column = 'name', string $key_column = 'id', ?string $order = null): SelectInterface
    {
        $select = InputSelect::new();

        if ($this->is_loaded or count($this->source)) {
            // Data was either loaded from DB or manually added. $value_column may contain query parts, strip em.
            $value_column = trim($value_column);
            $value_column = Strings::fromReverse($value_column, ' ');
            $value_column = str_replace('`', '', $value_column);
            $select->setSource($this->getScalarValuesSource($value_column));

        } else {
            $query = 'SELECT   `' . $key_column . '`, ' . $value_column . ' 
                                                FROM     `' . static::getTable() . '` 
                                                WHERE    `status` IS NULL';

            if ($order === null) {
                // Default order by the value column. Value column may have SQL, make sure its stripped
                $order = Strings::fromReverse($value_column, ' ') . ' ASC';
            }

            // Only order if an order column has been specified
            if ($order) {
                $query .= ' ORDER BY ' . $order;
            }

            // No data was loaded from DB or manually added
            $select->setSourceQuery($query);
        }

        return $select;
    }


    /**
     * Creates and returns a CLI table for the data in this list
     *
     * @param array|null $columns
     * @param array $filters
     * @param string|null $id_column
     * @return void
     */
    public function CliDisplayTable(?array $columns = null, array $filters = [], ?string $id_column = 'id'): void
    {
        Cli::displayTable($this->source, $columns, $id_column);
    }


    /**
     * Set the specified status for the specified entries
     *
     * @param string|null $status
     * @param array $entries
     * @param string|null $comments
     * @return int
     */
    public function setStatus(?string $status, array $entries, ?string $comments = null): int
    {
        return sql()->dataEntrySetStatus($status, static::getTable(), $entries, $comments);
    }


    /**
     * Delete the specified entries
     *
     * @param array $entries
     * @param string|null $comments
     * @return int
     */
    public function dbDelete(array $entries, ?string $comments = null): int
    {
showdie('$entries IS IN CORRECT HERE, AS SQL EXPECTS IT, IT SHOULD BE AN ARRAY FOR A SINGLE ROW!');
        return $this->setStatus('deleted', $entries, $comments);
    }


    /**
     * Undelete the specified entries
     *
     * @param array $entries
     * @param string|null $comments
     * @return int
     */
    public function dbUndelete(array $entries, ?string $comments = null): int
    {
showdie('$entries IS IN CORRECT HERE, AS SQL EXPECTS IT, IT SHOULD BE AN ARRAY FOR A SINGLE ROW!');
        return $this->setStatus(null, $entries, $comments);
    }


    /**
     * Returns an array with all id's for the specified entry identifiers
     *
     * @param array $identifiers
     * @return array
     */
    public function listIds(array $identifiers): array
    {
        if ($identifiers) {
            $in = Sql::in($identifiers);

            return sql()->list('SELECT `id` 
                                  FROM   `' . static::getTable() . '` 
                                  WHERE  `' . static::getUniqueField() . '` IN (' . implode(', ', array_keys($in)) . ')', $in);
        }

        return [];
    }


    /**
     * Add the specified data entry to the data list
     *
     * @param DataEntry|null $entry
     * @return static
     */
    public function addDataEntry(?DataEntryInterface $entry): static
    {
        if ($entry) {
            $this->source[$entry->getId()] = $entry;
        }

        return $this;
    }


    /**
     * Remove the specified key(s) from the data list
     *
     * @param DataEntryInterface|array|string|float|int $keys
     * @return static
     */
    public function delete(DataEntryInterface|array|string|float|int $keys): static
    {
        if (is_object($keys)) {
            $keys = $keys->getId();
        }

        return parent::delete($keys);
    }


    /**
     * Returns the current item
     *
     * @return DataEntry|null
     */
    #[ReturnTypeWillChange] public function current(): ?DataEntryInterface
    {
        return $this->ensureDataEntry(key($this->source));
    }


    /**
     * Returns the first element contained in this object without changing the internal pointer
     *
     * @return DataEntryInterface|null
     */
    #[ReturnTypeWillChange] public function getFirst(): ?DataEntryInterface
    {
        return $this->ensureDataEntry(array_key_first($this->source));
    }


    /**
     * Returns the last element contained in this object without changing the internal pointer
     *
     * @return DataEntryInterface|null
     */
    #[ReturnTypeWillChange] public function getLast(): ?DataEntryInterface
    {
        return $this->ensureDataEntry(array_key_last($this->source));
    }


    /**
     * Ensure the entry we're going to return is from DataEntryInterface interface
     *
     * @param string|float|int $key
     * @return DataEntryInterface
     */
    protected function ensureDataEntry(string|float|int $key): DataEntryInterface
    {
        // Ensure the source key is of DataEntryInterface
        if (!$this->source[$key] instanceof DataEntryInterface) {
            $this->source[$key] = static::getEntryClass()::new()->setSource($this->source[$key]);
        }

        return $this->source[$key];
    }


    /**
     * Will throw an OutOfBoundsException exception if no parent was set for this list
     *
     * @param string $action
     * @return void
     */
    protected function ensureParent(string $action): static
    {
        if (!$this->parent) {
            throw new OutOfBoundsException(tr('Cannot ":action", no parent specified', [':action' => $action]));
        }

        return $this;
    }


    /**
     * Ensures that all objects in the source are entry_class objects
     *
     * @return $this
     */
    protected function ensureSourceObjects(): static
    {
        foreach ($this->source as &$value) {
            if (is_object($value)) {
                continue;
            }

            $value = static::getEntryClass()::new()->setSource($value);
        }

        unset($value);
        return $this;
    }


    /**
     * Returns an array with scalar values
     *
     * @param string $column
     * @return array
     */
    protected function getScalarValuesSource(string $column): array
    {
        $return = [];

        foreach ($this->source as $key => $value) {
            $return[$key] = $value[$column];
        }

        return $return;
    }


    /**
     * Returns an array with scalar values
     *
     * @param array|string|null $columns
     * @return array
     */
    protected function getSourceColumns(array|string|null $columns): array
    {
        if (!$columns) {
            // No columns specified, return everything
            return $this->source;
        }

        $return  = [];
        $columns = Arrays::force($columns);

        foreach ($this->source as $key => $value) {
            if (is_object($value)) {
                // Extract array data from DataEntry object
                $value = $value->__toArray();
            }

            $return[$key] = Arrays::keep($value, $columns);
        }

        return $return;
    }


    /**
     * Selects if we use the default query or a query from the QueryBuilder
     *
     * @return void
     */
    protected function selectQuery(): void
    {
        // Use the default html_query and html_execute or QueryBuilder html_query and html_execute?
        if (isset($this->query_builder)) {
            $this->query   = $this->query_builder->getQuery();
            $this->execute = $this->query_builder->getExecute();

        } elseif (!isset($this->query)) {
            throw new OutOfBoundsException(tr('Cannot generate HMTL table for ":class", no html query specified', [
                ':class' => get_class($this)
            ]));
        }
    }


    /**
     * Load the id list from database
     *
     * @param string|null $id_column
     * @return static
     */
    public function load(?string $id_column = null): static
    {
        $this->selectQuery();
        $this->source = sql()->list($this->query, $this->execute);

        return $this;
    }
}